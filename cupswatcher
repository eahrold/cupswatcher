#!/bin/bash

#####################################################
#####################################################
##      Sick of CUPS queues pausing for no reason,  #
##      Leaving your labs stuck for the night?      #
##      Me too.                                     #
##      So I wrote this little script               #
##      To cancel jobs and restart queues.          #
##                                                  #
#####################################################
#####################################################

#####  Configure these to suite your os X environment
VERSION="1.2"
REVERSE_DOMAIN="com.eeaapps.cupswatcher"
CUPSWATCHER_PATH=/usr/local/sbin/
CUPS_LAUNCHD="/System/Library/LaunchDaemons/org.cups.cupsd.plist"

TIMER=30
OSKERN=`sysctl -n kern.ostype`
LOG_FILE="/var/log/cupswatcher.log"

case "$1" in

### install self and create LauchD plist file
-v|--version)
	echo $VERSION
	exit 0
;;
-i|--install)
	##### test if run as root/sudoed
	if [ `whoami` == "root" ] ; then 
		[[ ! -d "$CUPSWATCHER_PATH" ]] && mkdir -pv "$CUPSWATCHER_PATH"
		cp "$0" "$CUPSWATCHER_PATH"			
		LAUNCHD_DIR="/Library/LaunchDaemons/"
		LAUNCHD_PATH="$LAUNCHD_DIR/$REVERSE_DOMAIN"

		### clear out any old launch
		LOADED_LAUNCHD=`launchctl list | grep cupswatcher | awk '{print $3}'`
		for LAUNCHD in ${LOADED_LAUNCHD[@]} ; do 
 			launchctl remove "$LAUNCHD"
 			echo unloading old version named "$LAUNCHD"
 		done
		rm $LAUNCHD_DIR/*.cupswatcher.*
		### this next part checks if the os is OS X and installs a launchD if it is so...
			if [ "$OSKERN" == "Darwin" ]; then
				echo "Making LaunchD plist file named $REVERSE_DOMAIN"
				defaults write "$LAUNCHD_PATH" Label "$REVERSE_DOMAIN"
				defaults write "$LAUNCHD_PATH" ProgramArguments -array "$CUPSWATCHER_PATH"cupswatcher
				defaults write "$LAUNCHD_PATH" StartInterval -int $TIMER
				chmod 644 "$LAUNCHD_PATH".plist
				echo "Loading cupswatcher into launchD"
				launchctl load "$LAUNCHD_PATH".plist
			fi
	else
		echo the installer needs to be run as root
	exit 1
	fi	
exit 0
;;

-r|--server)
	##### test if run as root/sudoed
	if [ `whoami` = "root" ] ; then 
		[[ ! -d "$CUPSWATCHER_PATH" ]] && mkdir -pv "$CUPSWATCHER_PATH"
		cp "$0" "$CUPSWATCHER_PATH"			

		### the server side uses the web interface to determin wether something's broken
		### so we'll turn it on 
		/usr/sbin/cupsctl WebInterface=yes
		
		### this next part checks if the os is OS X and installs a launchD if it is so...
			if [ "$OSKERN" == "Darwin" ]; then
				echo "Making LaunchD plist file named com.eeaapps.cupswatcher"
				echo "The file is located at ${LAUNCHD_PATH}"
				defaults write "$LAUNCHD_PATH" Label com.aapps.cupswatcher
				defaults write "$LAUNCHD_PATH" ProgramArguments -array "$CUPSWATCHER_PATH/cupswatcher" "-s"
				defaults write "$LAUNCHD_PATH" StartInterval -int $TIMER
				chmod 644 "$LAUNCHD_PATH".plist
				[[ "$(launchctl list | grep -c cupswatcher)" = "1" ]] && launchctl unload "$LAUNCHD_PATH".plist && echo unloading old versionâ€¦
				echo "Loading cupswatcher into launchD"
				launchctl load "$LAUNCHD_PATH".plist
			fi
	else
		echo the installer needs to be run as root
	exit 1
	fi	
exit 0
;;

##### otherwise continue
*)

_reload_cups(){
	launchctl unload ${CUPS_LAUNCHD}
	sleep 2
	launchctl load ${CUPS_LAUNCHD}
	exit 1
}


### run an extra routine if this is a server
if [ "$1" ==  "-s" ]; then 
	SERVER_STATUS=$(curl --silent http://127.0.0.1:631/printers/)
	RC=$?
	
	if [ $RC -gt 0 ]; then
		echo -e "The Server was restarted on $(date) due to a Print Server Crash" >> $LOG_FILE
		_reload_cups
	
	else
		PRINTER_ERROR=`echo $SERVER_STATUS | grep -c -w 'Internal Server Error'`
		if [ $PRINTER_ERROR -gt 0 ]; then 
			echo -e "The Server was restarted on $(date) due to an Printer Availability Error" >> $LOG_FILE
			_reload_cups
		fi
	fi
fi


#### set up varibles
CUPSWATHCER_TMPDIR="/private/tmp/${REVERSE_DOMAIN}/"
ENABLE_PRINTER="/usr/sbin/cupsenable"
CANCEL_LAST_JOB="/usr/bin/lprm -P"

[[ ! -d "$CUPSWATHCER_TMPDIR" ]] && mkdir -p "$CUPSWATHCER_TMPDIR"
[[ -z "$LOG_FILE" ]] && touch $LOG_FILE && chown root:admin $LOG_FILE && chmod 750 $LOG_FILE 

### Find any paused printers
PAUSED_PRINTER_LIST=$( /usr/bin/lpstat -p | grep disabled | awk '{printf $2 " "}')
if [ -n "$PAUSED_PRINTER_LIST" ] ; then
	for PRINTER in ${PAUSED_PRINTER_LIST[@]} ; do 
#### if the same print job has stopped the queue twice, delete it (otherwise just restart the queue)  	
	LAST_JOB=`/usr/bin/lpstat  -W not-completed -o $PRINTER | head -1 | awk '{print $1}'`
	if [ -n "$LAST_JOB" ] ; then 
		if [ -f "$CUPSWATHCER_TMPDIR/$LAST_JOB" ] ; then
			$CANCEL_LAST_JOB "$PRINTER"
			rm "$CUPSWATHCER_TMPDIR/$LAST_JOB"
			echo "$PRINTER" was resumed and job "$LAST_JOB" was canceled on $(date) >> $LOG_FILE
	
		else
			touch "$CUPSWATHCER_TMPDIR/$LAST_JOB"
			echo "$PRINTER" was resumed and job $"LAST_JOB" is was monitored on $(date) >> $LOG_FILE
		fi
	else
		echo "$PRINTER" was resumed on $(date) >> $LOG_FILE
	fi
	$ENABLE_PRINTER $PRINTER
	done
fi


exit 0
;;



#### end case
esac
exit 0 ;
